<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>video</title>
    <style>
        #yourVideo{
            position: absolute;
            right: 0px;
            top: 20px;
        }
    </style>
</head>
<body>
<div>peng</div>
<video id="myVideo">a</video>
<video id="yourVideo">a</video>

<script>
    var signalingChannel, key, id,
        haveLocalMedia = false,
        weWaited = false,
        myVideoStream, myVideo,
        yourVideoStream, yourVideo,
        doNothing = function () { },
        pc,
        constraints = {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: true
            }
        }

    // 获取本地媒体
    function getMedia() {
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

        var constr = {audio: false, video: true};
        navigator.getUserMedia(constr, gotUserMedia, didntGetUserMedia);
    }
    function didntGetUserMedia() {
        console.log('cound not get user media')
    }
    function gotUserMedia(stream) {
        console.log("getmedia")
        myVideoStream = stream
        haveLocalMedia = true
        // 向我显示我的本地视频
        myVideo.srcObject = myVideoStream
        myVideo.play()
        // 等待pc创建完毕
        attachMediaIfReady()
    }

    function attachMediaIfReady() {
        console.log("attachMedia")
        attachMedia()
    }

    // 自动开始获取本地媒体
    window.onload = function () {
        // if (queryParams && queryParams['key']) {    // 加载空白脚本中预置的queryParams参数
        //     document.getElementById('key').value = queryParams['key']
        initPeer()
        // }
        myVideo = document.getElementById('myVideo')
        yourVideo = document.getElementById('yourVideo')
        getMedia()
    }

    // 连接服务器并建立信令通道
    function connect() {
        var errorCB, scHandlers, handleMsg
        // 获取连接密钥
        key = "peng"
        // 处理通过信令通道收到的所有消息
        handleMsg = function (msg) {
            // var msgE = document.getElementById('inmessages')
            // var msgString = JSON.stringify(msg).replace(/\\r\\n/g, '\n')
            // msgE.value = msgString + '\n' + msgE.value    // 将最新的消息放置在最上方
            console.log('msgString:', msgString)
            if (msg.type === 'offer') {
                pc.setRemoteDescription(new RTCSessionDescription(msg))
                answer()
            } else if (msg.type === 'answer') {
                pc.setRemoteDescription(new RTCSessionDescription(msg))
            } else if (msg.type === 'candidate') {
                pc.addIceCandidate(new RTCIceCandidate({
                    sdpMLineIndex: msg.mlineindex,
                    candidate: msg.candidate
                }))
            }
        }
        scHandlers = {
            'onWaiting': function () {
                // setStatus('Waiting')
                weWaited = true
            },
            'onConnected': function () {
                // setStatus('Connected')
                // 已成功连接，开始建立对等连接
                initPeer()
            },
            'onMessage': handleMsg
        }
        // 创建信令通道
        signalingChannel = createSignalingChannel(key, scHandlers)
        errorCB = function (msg) {
            document.getElementById('response').innerHTML = msg
        }

        // 进行连接
        signalingChannel.connect(errorCB)
        console.log("channel")
    }

    // 通过信道发送消息
    function send(msg) {
        var handler = function (res) {
            //document.getElementById('response').innerHTML = res
            console.log("hand")
            return
        }
        //msg = msg //|| document.getElementById('message').value   // 没有消息则获取信道消息
        // 发布到屏幕上
        // msgE = document.getElementById('outmessages')
        // var msgString = JSON.stringify(msg).replace(/\\r\\n/g, '\n')
        // msgE.value = msgString + '\n' + msgE.value
        // 通过信令通道发送出去
        signalingChannel.send(msg, handler)
        console.log("send")
    }



    function initPeer(){
        var iceServer = {
            "iceServers": [{
                "url": "turn:fw.hiwonder.com:3478",
                "credential":"123456",
                "username":"admin"
            }]
        };
        pc = new RTCPeerConnection(iceServer);

        pc.onicecandidate = onIceCandidate
        pc.onaddstream = onRemoteStreamAdded
        pc.onremovestream = onRemoteStreamRemoved
        var mg = {
            "sdp":"peng",
            "type":"offer"
        }
        pc.setRemoteDescription(new RTCSessionDescription(mg))
        answer()
        setTimeout(function () {
            var mg = {
                "sdp":"peng",
                "type":"answer"
            }
            pc.setRemoteDescription(new RTCSessionDescription(mg))
        },500)

        console.log("initpeer")
    }

    // 如果当前浏览器有另一个候选项，将其发送给对等端
    function onIceCandidate(e) {
        console.log("onice")
        // if (e.candidate) {
        //     send({
        //         type: 'candidate',
        //         mlineindex: e.candidate.sdpMLineIndex,
        //         candidate: e.candidate.candidate
        //     })
        // }
        pc.addIceCandidate(new RTCIceCandidate({
            sdpMLineIndex: 2,
            candidate: "peng"
        }))
    }

    // 如果我们浏览器检测到另一端加入了媒体流，则将其显示在屏幕上
    function onRemoteStreamAdded(e) {
        yourVideoStream = e.stream
        console.log('yourVideo: ', yourVideo)
        yourVideo.srcObject = yourVideoStream
        // setStatus('On call')
    }

    // 远端移除流，这里不做操作
    function onRemoteStreamRemoved(e) {
        console.log("remove")
    }



    // 将本地流添加至对等连接
    function attachMedia() {
        pc.addStream(myVideoStream)
        console.log("addstream")
        // setStatus('Ready for call')
        // if (queryParams && queryParams['call'] && !weWaited) {
            call()
        // }
    }

    // 生成一个offer
    function call() {
        console.log("call")
        pc.createOffer(gotDescription, doNothing, constraints)
    }

    // 应答会话描述，生成answer
    function answer() {
        console.log("answer")
        pc.createAnswer(gotDescription, doNothing, constraints)
    }

    // 一旦获取到了会话描述，就将其作为本地描述，然后将其发送至另一端的浏览器
    function gotDescription(localDesc) {
        pc.setLocalDescription(localDesc)
        // send(localDesc)
        console.log("gotDescription")
        console.log(localDesc)
    }


    var createSignalingChannel = function (key, handlers) {

        var id, status,
            doNothing = function () { },
            handlers = handlers || {},
            initHandler = function (h) {
                return ((typeof h === 'function') && h) || doNothing;
            },
            waitingHandler = initHandler(handlers.onWaiting),
            connectedHandler = initHandler(handlers.onConnected),
            messageHandler = initHandler(handlers.onMessage);


        // Set up connection with signaling server
        function connect(failureCB) {
            var failureCB = (typeof failureCB === 'function') ||
                function () { };

            // Handle connection response, which should be error or status
            //  of "connected" or "waiting"
            function handler() {
                if (this.readyState == this.DONE) {
                    if (this.status == 200 && this.response != null) {
                        var res = JSON.parse(this.response);
                        if (res.err) {
                            failureCB("error:  " + res.err);
                            return;
                        }

                        // if no error, save status and server-generated id,
                        // then start asynchronouse polling for messages
                        id = res.id;
                        status = res.status;
                        poll();

                        // run user-provided handlers for waiting and connected
                        // states
                        if (status === "waiting") {
                            waitingHandler();
                        } else {
                            connectedHandler();
                        }
                        return;
                    } else {
                        failureCB("HTTP error:  " + this.status);
                        return;
                    }
                }
            }

            // open XHR and send the connection request with the key
            var client = new XMLHttpRequest();
            client.onreadystatechange = handler;
            client.open("GET", "/connect?key=" + key);
            client.send();
        }

        // poll() waits n ms between gets to the server.  n is at 10 ms
        // for 10 tries, then 100 ms for 10 tries, then 1000 ms from then
        // on. n is reset to 10 ms if a message is actually received.
        function poll() {
            var msgs;
            var pollWaitDelay = (function () {
                var delay = 10, counter = 1;

                function reset() {
                    delay = 10;
                    counter = 1;
                }

                function increase() {
                    counter += 1;
                    if (counter > 20) {
                        delay = 1000;
                    } else if (counter > 10) {
                        delay = 100;
                    }                          // else leave delay at 10
                }

                function value() {
                    return delay;
                }

                return { reset: reset, increase: increase, value: value };
            } ());

            // getLoop is defined and used immediately here.  It retrieves
            // messages from the server and then schedules itself to run
            // again after pollWaitDelay.value() milliseconds.
            (function getLoop() {
                get(function (response) {
                    var i, msgs = (response && response.msgs) || [];

                    // if messages property exists, then we are connected
                    if (response.msgs && (status !== "connected")) {
                        // switch status to connected since it is now!
                        status = "connected";
                        connectedHandler();
                    }
                    if (msgs.length > 0) {           // we got messages
                        pollWaitDelay.reset();
                        for (i = 0; i < msgs.length; i += 1) {
                            handleMessage(msgs[i]);
                        }
                    } else {                         // didn't get any messages
                        pollWaitDelay.increase();
                    }

                    // now set timer to check again
                    setTimeout(getLoop, pollWaitDelay.value());
                });
            } ());
        }


        // This function is part of the polling setup to check for
        // messages from the other browser.  It is called by getLoop()
        // inside poll().
        function get(getResponseHandler) {

            // response should either be error or a JSON object.  If the
            // latter, send it to the user-provided handler.
            function handler() {
                if (this.readyState == this.DONE) {
                    if (this.status == 200 && this.response != null) {
                        var res = JSON.parse(this.response);
                        if (res.err) {
                            getResponseHandler("error:  " + res.err);
                            return;
                        }
                        getResponseHandler(res);
                        return res;
                    } else {
                        getResponseHandler("HTTP error:  " + this.status);
                        return;
                    }
                }
            }

            // open XHR and request messages for my id
            var client = new XMLHttpRequest();
            client.onreadystatechange = handler;
            client.open("POST", "/get");
            client.send(JSON.stringify({ "id": id }));
        }


        // Schedule incoming messages for asynchronous handling.
        // This is used by getLoop() in poll().
        function handleMessage(msg) {   // process message asynchronously
            setTimeout(function () { messageHandler(msg); }, 0);
        }


        // Send a message to the other browser on the signaling channel
        function send(msg, responseHandler) {
            var reponseHandler = responseHandler || function () { };

            // parse response and send to handler
            function handler() {
                if (this.readyState == this.DONE) {
                    if (this.status == 200 && this.response != null) {
                        var res = JSON.parse(this.response);
                        if (res.err) {
                            responseHandler("error:  " + res.err);
                            return;
                        }
                        responseHandler(res);
                        return;
                    } else {
                        responseHandler("HTTP error:  " + this.status);
                        return;
                    }
                }
            }

            // open XHR and send my id and message as JSON string
            var client = new XMLHttpRequest();
            client.onreadystatechange = handler;
            client.open("POST", "/send");
            var sendData = { "id": id, "message": msg };
            client.send(JSON.stringify(sendData));
        }


        return {
            connect: connect,
            send: send
        };

    };
</script>
</body>
</html>